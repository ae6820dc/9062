<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>96! v43</title>
<style>
  :root{
    --bg:#0f1420; --tile-on:#3ec7c2; --tile-off:#2a3550;
    --ink:#e8eef8; --muted:#9fb3c8; --digit-ink:#e7f0ff; --gap:10px;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial;
    display:flex; flex-direction:column; align-items:center;
    -webkit-tap-highlight-color: transparent;
  }
  h1{font-size:18px; font-weight:700; margin:10px 0 8px}
  #frame{display:flex; flex-direction:column; align-items:center}
  .hud{width:100%; box-sizing:border-box; display:flex; flex-direction:column; gap:6px; color:var(--muted); font-size:20px; padding:0 4px;}
  .row{display:flex; align-items:baseline; gap:8px; min-width:0}
  .row .label{white-space:nowrap}
  .value{display:block; width:100%; overflow-x:auto; white-space:nowrap; padding-bottom:2px; border-bottom:1px dashed rgba(231,240,255,0.2);}  
  canvas{display:block; position:relative}
  .bar{width:100%; display:flex; justify-content:center; gap:var(--gap); flex-wrap:wrap}
  button{
    margin:12px 0 14px; padding:0; border:none; border-radius:0px;
    background:var(--tile-off); color:var(--digit-ink); font-weight:700;
    touch-action:manipulation; user-select:none;
    width:64px; height:64px; min-width:unset; display:flex; align-items:center; justify-content:center;
  }
  .btn-on{ background:var(--tile-on)!important; color:#0a1320!important; }
  @media (max-width:420px){ .hud{font-size:18px; gap:5px; padding:0 2px} h1{font-size:16px} }
  .hud, .hud .label, .value .real { color: var(--ink); font-weight:700; }
</style>
</head>
<body>
<h1>96! v43</h1>
<div id="frame">
  <div class="hud" id="hud">
    <div class="row">
      <span class="label">Step:</span>
      <div id="sValue" class="value" aria-label="Step counter"><span class="real">0</span></div>
    </div>
    <div class="row">
      <span class="label">Score:</span>
      <div id="mValue" class="value" aria-label="Score counter"><span class="real">0</span></div>
    </div>
  </div>
  <canvas id="stage" aria-label="8×12 toggleable grid"></canvas>
  <div class="bar">
    <button id="n0" aria-label="N0" aria-pressed="false">N0</button>
    <button id="n1" aria-label="N1" aria-pressed="false">N1</button>
    <button id="n2" aria-label="N2" aria-pressed="false">N2</button>
    <button id="n3" aria-label="N3" aria-pressed="false">N3</button>
    <button id="autoToggle" aria-label="Auto Random Fill & Clear" aria-pressed="false">R</button>
  </div>
</div>
<script>
(()=> {
  const COLS=8, ROWS=12; // MÓDOSÍTVÁ: 8 oszlop, 12 sor = 96 csempe
  const DPR=Math.max(1, Math.min(window.devicePixelRatio||1, 2));
  const canvas=document.getElementById('stage');
  const ctx=canvas.getContext('2d');
  const css=v=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const COLORS={ BG:css('--bg'), ON:css('--tile-on'), OFF:css('--tile-off'), INK:css('--ink'), DIGIT_INK:css('--digit-ink') };
  const grid={ cols:COLS, rows:ROWS, size:0, pad:10, radius:0 };
  
  function emptyMatrix(){ return Array.from({length:grid.rows},()=>Array(grid.cols).fill(false)); }
  const defaultBoardState = ()=>({ matrix: emptyMatrix(), step: "0", score: "0" });
  let boardsState = Array.from({length:16}, defaultBoardState);
  let activeButtons = [false,false,false,false];
  let viewIndex = 0;
  let autoToggleInterval = null;
  let isAutoToggleActive = false;
  
  // Új változók az új logikához - MÓDOSÍTVÁ: mentjük a fázist is
  let isFillingPhase = true; // true = bekapcsolás fázis, false = kikapcsolás fázis
  
  const elM=document.getElementById('mValue');
  const elS=document.getElementById('sValue');
  const hud=document.getElementById('hud');
  const frame=document.getElementById('frame');
  const btns=[
    document.getElementById('n0'),
    document.getElementById('n1'),
    document.getElementById('n2'),
    document.getElementById('n3'),
    document.getElementById('autoToggle'),
  ];

  const STORAGE_KEY=`v35_sync_on_empty_${COLS}x${ROWS}_combo16`;

  // ---------- Big integer helpers ----------
  const stripZeros = (s)=>{
    let t = (s||'0').replace(/^(-?)0+(?=\d)/, '$1');
    return t === '' ? '0' : t;
  };
  const splitSign = (s)=> s[0]==='-' ? [-1, s.slice(1)] : [1, s];
  const cmpAbs = (a,b)=>{
    if (a.length!==b.length) return a.length - b.length;
    if (a===b) return 0;
    return a<b ? -1 : 1;
  };
  const addAbs = (a,b)=>{
    a = stripZeros(a); b = stripZeros(b);
    let res='',carry=0,i=a.length-1,j=b.length-1;
    while(i>=0||j>=0||carry){
      const da=i>=0?(a.charCodeAt(i)-48):0;
      const db=j>=0?(b.charCodeAt(j)-48):0;
      const s=da+db+carry;
      res=(s%10)+res; carry=(s/10)|0; i--; j--;
    }
    return stripZeros(res);
  };
  const subAbs = (a,b)=>{ // assumes a>=b
    a = stripZeros(a); b = stripZeros(b);
    let res='',borrow=0,i=a.length-1,j=b.length-1;
    while(i>=0){
      let da=a.charCodeAt(i)-48-borrow;
      const db=j>=0?(b.charCodeAt(j)-48):0;
      if(da<db){ da+=10; borrow=1; } else borrow=0;
      res=(da-db)+res; i--; j--;
    }
    return stripZeros(res.replace(/^0+(?=\d)/,''));
  };
  const addSigned = (A, B)=>{ // for score (+2 / -1)
    let [sa, a] = splitSign(stripZeros(A));
    let [sb, b] = splitSign(stripZeros(B));
    if (a==='0' && sa===1) return (sb<0?'-':'')+b;
    if (b==='0' && sb===1) return (sa<0?'-':'')+a;
    if (sa===sb){
      const s = addAbs(a,b);
      return (sa<0?'-':'')+s;
    } else {
      const cmp = cmpAbs(a,b);
      if (cmp===0) return '0';
      if (cmp>0){
        const s = subAbs(a,b);
        return (sa<0?'-':'')+s;
      } else {
        const s = subAbs(b,a);
        return (sb<0?'-':'')+s;
      }
    }
  };
  const incUnsigned = (A)=> stripZeros(addAbs(stripZeros(A), '1'));

  // floor(A/2) for unsigned big integer string
  const halfUnsigned = (A)=>{
    A = stripZeros(A);
    let res = '';
    let carry = 0;
    for (let i=0;i<A.length;i++){
      const n = carry*10 + (A.charCodeAt(i)-48);
      const q = (n/2)|0;
      res += String(q);
      carry = n % 2;
    }
    return stripZeros(res);
  };

  const isBoardEmpty = (m)=>{
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        if(m[r][c]) return false;
      }
    }
    return true;
  };

  // ÚJ: meghatározza a jelenlegi fázist a tábla állapota alapján
  function determineCurrentPhase() {
    const b = boardsState[viewIndex];
    let onCount = 0;
    let offCount = 0;
    
    for(let r = 0; r < grid.rows; r++) {
      for(let c = 0; c < grid.cols; c++) {
        if(b.matrix[r][c]) {
          onCount++;
        } else {
          offCount++;
        }
      }
    }
    
    // Ha több ki van kapcsolva, akkor bekapcsolás fázisban vagyunk
    // Ha több be van kapcsolva, akkor kikapcsolás fázisban vagyunk
    // Döntetlen esetén: bekapcsolással kezdünk
    return offCount >= onCount;
  }

  // ÚJ: megtalálja a következő pozíciót az aktuális fázisnak megfelelően
  function findNextPositionForPhase() {
    const b = boardsState[viewIndex];
    
    if (isFillingPhase) {
      // Bekakcsolás fázis: keresünk egy kikapcsolt csempét
      const offPositions = [];
      for(let r = 0; r < grid.rows; r++) {
        for(let c = 0; c < grid.cols; c++) {
          if(!b.matrix[r][c]) {
            offPositions.push({r, c});
          }
        }
      }
      
      if (offPositions.length === 0) {
        // Nincs több kikapcsolt, váltunk fázist
        isFillingPhase = false;
        return findNextPositionForPhase();
      }
      
      // Véletlenszerű kikapcsolt csempe
      return offPositions[Math.floor(Math.random() * offPositions.length)];
    } else {
      // Kikapcsolás fázis: keresünk egy bekapcsolt csempét
      const onPositions = [];
      for(let r = 0; r < grid.rows; r++) {
        for(let c = 0; c < grid.cols; c++) {
          if(b.matrix[r][c]) {
            onPositions.push({r, c});
          }
        }
      }
      
      if (onPositions.length === 0) {
        // Nincs több bekapcsolt, váltunk fázist
        isFillingPhase = true;
        return findNextPositionForPhase();
      }
      
      // Véletlenszerű bekapcsolt csempe
      return onPositions[Math.floor(Math.random() * onPositions.length)];
    }
  }

  function maskFromButtons(){
    return (activeButtons[0]?1:0) | (activeButtons[1]?2:0) | (activeButtons[2]?4:0) | (activeButtons[3]?8:0);
  }
  
  function renderValue(el, v){
    el.innerHTML='<span class="real">'+v+'</span>';
    requestAnimationFrame(()=>{ el.scrollLeft=el.scrollWidth; });
  }
  
  function syncHUD(){ 
    const b = boardsState[viewIndex];
    renderValue(elM, b.score);
    renderValue(elS, b.step);
    saveState(); 
  }

  // MÓDOSÍTVÁ: Egyszerűsített processNextTile
  function processNextTile() {
    const b = boardsState[viewIndex];
    const pos = findNextPositionForPhase();
    const r = pos.r;
    const c = pos.c;
    
    if (isFillingPhase) {
      // Bekakcsolás
      b.matrix[r][c] = true;
      b.score = addSigned(b.score, "-1"); // MÓDOSÍTVÁ: +2 helyett -1
    } else {
      // Kikapcsolás
      b.matrix[r][c] = false;
      b.score = addSigned(b.score, "2"); // MÓDOSÍTVÁ: -1 helyett +2
    }
    
    b.step = incUnsigned(b.step);
    
    // Sync only when board is empty and we've made at least one move
    if (isBoardEmpty(b.matrix) && b.step !== "0"){
      b.score = halfUnsigned(b.step);
    }
    
    syncHUD();
    draw();
  }

  // Automatikus random kitöltés/kiürítés funkció
  function autoProcess() {
    if (!isAutoToggleActive) return;
    processNextTile();
  }

  function startAutoToggle() {
    if (autoToggleInterval) return;
    isAutoToggleActive = true;
    
    // MÓDOSÍTVÁ: Nem állítjuk alaphelyzetbe a fázist, hanem meghatározzuk
    isFillingPhase = determineCurrentPhase();
    
    autoToggleInterval = setInterval(autoProcess, 1); // 200ms = lassabb, jól látható
  }

  function stopAutoToggle() {
    isAutoToggleActive = false;
    if (autoToggleInterval) {
      clearInterval(autoToggleInterval);
      autoToggleInterval = null;
    }
  }

  function toggleAutoMode() {
    if (isAutoToggleActive) {
      stopAutoToggle();
    } else {
      startAutoToggle();
    }
    renderButtons();
  }

  function rr(x,y,w,h,r){ const a=Math.min(r,w/2,h/2);
    ctx.beginPath(); ctx.moveTo(x+a,y); ctx.arcTo(x+w,y,x+w,y+h,a);
    ctx.arcTo(x+w,y+h,x,y+h,a); ctx.arcTo(x,y+h,x,y,a); ctx.arcTo(x,y,x+w,y,a); ctx.closePath();
  }
  
  function drawHex(cx,cy,txt,isOn){
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='700 '+Math.max(16,Math.floor(grid.size*0.42))+'px Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle=isOn?'#0a1320':COLORS.DIGIT_INK;
    ctx.fillText(txt,cx,cy);
  }
  
  function draw(){
    const b = boardsState[viewIndex];
    ctx.fillStyle=COLORS.BG; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const idx=r*grid.cols+c;
        const hex=(idx % 16).toString(16).toUpperCase();
        const x=c*(grid.size+grid.pad)+grid.pad, y=r*(grid.size+grid.pad)+grid.pad;
        rr(x,y,grid.size,grid.size,grid.radius);
        const on=b.matrix[r][c]; ctx.fillStyle=on?COLORS.ON:COLORS.OFF; ctx.fill(); 
        drawHex(x+grid.size/2, y+grid.size/2, hex, on);
      }
    }
  }
  
  function pointerXY(e){ const rect=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top; return {x,y}; }
  
  function toggleAt(x,y){
    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const cx=c*(grid.size+grid.pad)+grid.pad, cy=r*(grid.size+grid.pad)+grid.pad;
        if(x>=cx && x<=cx+grid.size && y<=cy+grid.size && y>=cy){ 
          const b = boardsState[viewIndex];
          const wasOn = b.matrix[r][c];
          
          if (wasOn) {
            b.matrix[r][c] = false;
            b.score = addSigned(b.score, "2");
          } else {
            b.matrix[r][c] = true;
            b.score = addSigned(b.score, "-1");
          }
          
          b.step = incUnsigned(b.step);
          
          if (isBoardEmpty(b.matrix) && b.step !== "0"){
            b.score = halfUnsigned(b.step);
          }
          
          syncHUD();
          draw(); 
          return; 
        }
      }
    }
  }
  
  canvas.addEventListener('click', e=>{ const p=pointerXY(e); toggleAt(p.x,p.y); });
  let touchMoved=false;
  canvas.addEventListener('touchstart', ()=>{ touchMoved=false; }, {passive:true});
  canvas.addEventListener('touchmove',  ()=>{ touchMoved=true;  }, {passive:true});
  canvas.addEventListener('touchend',   e=>{ if(!touchMoved){ const p=pointerXY(e); toggleAt(p.x,p.y); } }, {passive:true});

  function renderButtons(){ 
    btns.forEach((btn, i)=>{
      if (i === 4) { // R gomb
        const on = isAutoToggleActive;
        btn.classList.toggle('btn-on', on); 
        btn.setAttribute('aria-pressed', String(on)); 
        btn.style.background = on ? COLORS.ON : COLORS.OFF;
        btn.style.color = on ? '#0a1320' : COLORS.DIGIT_INK;
        // A szöveg mindig "R" marad
        btn.textContent = 'R';
      } else {
        const on = !!activeButtons[i];
        btn.classList.toggle('btn-on', on); 
        btn.setAttribute('aria-pressed', String(on)); 
        btn.style.background = on ? COLORS.ON : COLORS.OFF;
        btn.style.color = on ? '#0a1320' : COLORS.DIGIT_INK;
      }
    });
  }
  
  function pressButton(index){
    if (index === 4) { // R gomb
      toggleAutoMode();
    } else {
      activeButtons[index] = !activeButtons[index];
      renderButtons();
      const m = maskFromButtons();
      viewIndex = m;
      saveState();
      syncHUD();
      draw();
    }
  }
  
  btns.forEach((btn, i)=>{
    btn.addEventListener('click', (e)=>{ e.preventDefault(); pressButton(i); });
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); pressButton(i); }, {passive:false});
  });

  function fitCanvas(){
    const outer=18, h1=document.querySelector('h1'), bar=document.querySelector('.bar');
    const h1H=h1?h1.getBoundingClientRect().height:0;
    const hudH=hud?hud.getBoundingClientRect().height:0;
    const barH=bar?bar.getBoundingClientRect().height:0;
    const safetyY=18;
    const maxW=Math.max(320, window.innerWidth-outer*2);
    const maxH=Math.max(260, window.innerHeight-(h1H+hudH+barH+safetyY+outer*2));
    grid.pad=Math.round(Math.max(10, Math.min(18, Math.min(maxW,maxH)*0.025)));
    const sizeFromW=Math.floor((maxW-(grid.pad*(grid.cols+1)))/grid.cols);
    const sizeFromH=Math.floor((maxH-(grid.pad*(grid.rows+1)))/grid.rows);
    const MAX_TILE=Math.min(96, Math.floor(window.innerWidth/5));
    grid.size=Math.min(MAX_TILE, Math.max(24, Math.min(sizeFromW,sizeFromH)));
    const cssW=grid.cols*(grid.size+grid.pad)+grid.pad;
    const cssH=grid.rows*(grid.size+grid.pad)+grid.pad;
    frame.style.width=cssW+'px';
    canvas.style.width=cssW+'px';
    canvas.style.height=cssH+'px';
    canvas.width=Math.round(cssW*DPR);
    canvas.height=Math.round(cssH*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    document.documentElement.style.setProperty('--gap', grid.pad + 'px');
    const tileFont = Math.max(16, Math.floor(grid.size*0.42)) + 'px';
    btns.forEach(btn=>{
      btn.style.width = grid.size + 'px';
      btn.style.height = grid.size + 'px';
      btn.style.borderRadius = grid.radius + 'px';
      btn.style.fontSize = tileFont;
    });
    draw();
  }

  function saveState(){ 
    try{ 
      // MÓDOSÍTVÁ: elmentjük a fázist is
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        boardsState, 
        activeButtons, 
        viewIndex,
        isAutoToggleActive: false, // JAVÍTVÁ: mindig false-ként mentjük
        isFillingPhase // elmentjük a fázist is
      })); 
    }catch(e){} 
  }
  
  function loadState(){
    try{
      const s=localStorage.getItem(STORAGE_KEY);
      if(s){
        const st=JSON.parse(s);
        if(st && Array.isArray(st.boardsState) && st.boardsState.length===16){
          boardsState = st.boardsState.map((b)=>{
            if(!b || !b.matrix) return defaultBoardState();
            if(typeof b.step !== 'string') b.step = '0';
            if(typeof b.score !== 'string') b.score = '0';
            return b;
          });
          if(Array.isArray(st.activeButtons) && st.activeButtons.length===4){ activeButtons = st.activeButtons.map(Boolean); }
          if(typeof st.viewIndex==='number') viewIndex = Math.max(0, Math.min(15, st.viewIndex));
          
          // JAVÍTVÁ: mindig false-ként töltjük be, NEM indítjuk el automatikusan
          isAutoToggleActive = false;
          
          // MÓDOSÍTVÁ: betöltjük a fázist
          if(typeof st.isFillingPhase === 'boolean') {
            isFillingPhase = st.isFillingPhase;
          } else {
            // Ha nincs mentve, meghatározzuk a tábla alapján
            isFillingPhase = determineCurrentPhase();
          }
          
          return true;
        }
      }
    }catch(e){ localStorage.removeItem(STORAGE_KEY); }
    return false;
  }

  window.addEventListener('resize', ()=>fitCanvas());
  window.addEventListener('orientationchange', ()=>fitCanvas());
  if(!loadState()){ boardsState = Array.from({length:16}, defaultBoardState); }
  renderButtons();
  syncHUD();
  draw();
  fitCanvas();
})();
</script>
</body>
</html>