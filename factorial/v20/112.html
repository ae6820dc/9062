<!DOCTYPE html>

<html lang="hu">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>112! v20</title>
<style>
    :root{
      --bg: #0f1420;
      --tile-on: #3ec7c2;
      --tile-off: #2a3550;
      --ink: #e8eef8;
      --muted: #9fb3c8;
      --digit-ink: #e7f0ff;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial;
      display:flex; flex-direction:column; align-items:center;
      -webkit-tap-highlight-color: transparent;
    }
    h1{font-size:18px; font-weight:700; margin:10px 0 8px}
    #frame{display:flex; flex-direction:column; align-items:center}
    .hud{
      width:100%;
      box-sizing:border-box;
      display:flex; flex-direction:column; gap:6px;
      color:var(--muted); font-size:20px;
      padding:0 4px;
    }
    .row{display:flex; align-items:baseline; gap:8px; min-width:0}
    .row .label{white-space:nowrap}
    #boardsHex{
      display:block; width:100%;
      overflow-x:auto; white-space:nowrap;
      padding-bottom:2px;
      border-bottom:1px dashed rgba(231,240,255,0.2);
    }
    canvas{display:block; position:relative}
    .bar{width:100%; display:flex; justify-content:center}
    button{
      margin:12px 0 14px;
      padding:12px 18px;
      border:none; border-radius:12px;
      background:var(--tile-off);
      color:var(--digit-ink);
      font-size:16px; font-weight:700;
      touch-action: manipulation;
      user-select: none;
    }
    @media (max-width: 420px){
      .hud{font-size:18px; gap:5px; padding:0 2px}
      h1{font-size:16px}
      button{font-size:15px}
    }
  
.hud, .hud .label, #onCount, #total, #boardsHex .real { color: var(--ink); font-weight: 700; }</style>
</head>
<body>
<h1>112! v20</h1>
<div id="frame">
<div class="hud" id="hud">
<div class="row"><span class="label">On:</span> <b id="onCount">0</b>/<b id="total">112</b></div>
<div class="row">
<span class="label">Boards:</span>
<div aria-label="14×8 kapcsolgatható rács, decimális Board-számlálóval" id="boardsHex"><span class="real">0</span></div>
</div>
</div>
<canvas aria-label="14×8 kapcsolgatható rács, decimális Board-számlálóval" id="stage"></canvas>
<div class="bar">
<button aria-pressed="false" id="resetBtn">Erase</button>
</div>
</div>
<script>
(()=>{
  const COLS=14, ROWS=8, TOTAL=COLS*ROWS; // 112
  const DPR = Math.max(1, Math.min(window.devicePixelRatio||1,2));
  const canvas=document.getElementById('stage');
  const ctx=canvas.getContext('2d');

  const getCSS=(v)=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const COLORS={
    BG: getCSS('--bg'),
    ON: getCSS('--tile-on'),
    OFF: getCSS('--tile-off'),
    INK: getCSS('--ink'),
    DIGIT_INK: getCSS('--digit-ink')
  };

  const grid={cols:COLS, rows:ROWS, size:0, pad:10};
  let matrix=[]; 
  let onCount=0;
  let boards = "0";
  let locked=false;
  let eraseOn = false;

  const elOn=document.getElementById('onCount');
  const elBoardsHex=document.getElementById('boardsHex');
  const resetBtn = document.getElementById('resetBtn');
  const hud = document.getElementById('hud');
  const frame = document.getElementById('frame');

  const STORAGE_KEY = '112v20_state';

  function fitCanvas(){
    const outerMargin = 18;
    const h1 = document.querySelector('h1');
    const bar = document.querySelector('.bar');

    const h1H  = h1  ? h1.getBoundingClientRect().height  : 0;
    const hudH = hud ? hud.getBoundingClientRect().height : 0;
    const barH = bar ? bar.getBoundingClientRect().height : 0;
    const safetyY = 18;

    const maxW = Math.max(320, window.innerWidth - outerMargin*2);
    const maxH = Math.max(260, window.innerHeight - (h1H + hudH + barH + safetyY + outerMargin*2));

    grid.pad = Math.round(Math.max(10, Math.min(18, Math.min(maxW, maxH) * 0.025)));
    const sizeFromW = Math.floor((maxW - (grid.pad*(grid.cols+1))) / grid.cols);
    const sizeFromH = Math.floor((maxH - (grid.pad*(grid.rows+1))) / grid.rows);

    const MAX_TILE = Math.min(96, Math.floor(window.innerWidth/5));
    grid.size = Math.min(MAX_TILE, Math.max(24, Math.min(sizeFromW, sizeFromH)));

    const cssW = grid.cols * (grid.size + grid.pad) + grid.pad;
    const cssH = grid.rows * (grid.size + grid.pad) + grid.pad;

    frame.style.width = cssW + 'px';

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * DPR);
    canvas.height = Math.round(cssH * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }

  function saveState(){
    const state = {
      matrix: matrix,
      onCount: onCount,
      boards: boards,
      eraseOn: eraseOn
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.error("Hiba a Local Storage mentésekor:", e);
    }
  }

  function loadState(){
    try {
      const storedState = localStorage.getItem(STORAGE_KEY);
      if(storedState){
        const state = JSON.parse(storedState);
        if(state.matrix && state.matrix.length === grid.rows && state.matrix[0].length === grid.cols){
          matrix = state.matrix;
          onCount = state.onCount || 0;
          boards = state.boards || "0";
          if (typeof state.eraseOn === 'boolean') {
              eraseOn = state.eraseOn;
          }
          return true;
        }
      }
    } catch (e) {
      console.warn("Hiba a Local Storage betöltésekor, az alapértelmezett állapot indul.", e);
      localStorage.removeItem(STORAGE_KEY);
    }
    return false;
  }

  function initMatrix(){
    if(!loadState()){
        matrix=Array.from({length:grid.rows},()=>Array(grid.cols).fill(false));
        onCount=0;
        boards="0";
        eraseOn=false;
    }
    locked = (onCount === TOTAL);
    syncHUD(true);
    renderErase();
    draw();
  }

  function rr(x,y,w,h,r){
    const a=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+a,y);ctx.arcTo(x+w,y,x+w,y+h,a);
    ctx.arcTo(x+w,y+h,x,y+h,a);ctx.arcTo(x,y+h,x,y,a);
    ctx.arcTo(x,y,x+w,y,a);ctx.closePath();
  }

  function drawHex(textX, textY, hex, isOn){
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font = `700 ${Math.max(16, Math.floor(grid.size*0.42))}px Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.fillStyle = isOn ? '#0a1320' : COLORS.DIGIT_INK;
    ctx.fillText(hex, textX, textY);
  }

  function draw(){
    ctx.fillStyle=COLORS.BG;
    ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const idx = r*grid.cols + c;
        const hex = idx.toString(16).toUpperCase().padStart(2,'0');
        const x=c*(grid.size+grid.pad)+grid.pad;
        const y=r*(grid.size+grid.pad)+grid.pad;

        rr(x,y,grid.size,grid.size,12);
        const on = matrix[r][c];
        ctx.fillStyle = on ? COLORS.ON : COLORS.OFF;
        ctx.fill();
        drawHex(x+grid.size/2, y+grid.size/2, hex, on);
      }
    }
  }

  function bigAdd(a, b) {
    let res = "", carry = 0;
    a = a.split("").reverse();
    b = b.split("").reverse();
    const n = Math.max(a.length, b.length);
    for (let i = 0; i < n; i++) {
      const da = i < a.length ? (a[i].charCodeAt(0)-48) : 0;
      const db = i < b.length ? (b[i].charCodeAt(0)-48) : 0;
      let sum = da + db + carry;
      res = (sum % 10) + res;
      carry = (sum / 10) | 0;
    }
    if (carry) res = carry + res;
    res = res.replace(/^0+/, "") || "0";
    return res;
  }

  function renderBoardsDisplay(value){
    elBoardsHex.innerHTML = `<span class="real">${value}</span>`;
    requestAnimationFrame(()=>{
      elBoardsHex.scrollLeft = elBoardsHex.scrollWidth;
    });
  }

  function syncHUD(initial=false){
    elOn.textContent = String(onCount);
    renderBoardsDisplay(boards);
    saveState();
  }

  function maybeLock(){
    if(onCount === TOTAL && !locked){
      locked = true;
      boards = bigAdd(boards, "1");
      syncHUD();
    }
  }

  function toggleCell(r,c){
    if(locked) return;
    matrix[r][c] = !matrix[r][c];
    onCount += matrix[r][c] ? 1 : -1;
    syncHUD();
    maybeLock();
    draw();
  }

  function toggleAt(x,y){
    if(locked) return;
    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const cx=c*(grid.size+grid.pad)+grid.pad;
        const cy=r*(grid.size+grid.pad)+grid.pad;
        if(x>=cx && x<=cx+grid.size && y>=cy && y<=cy+grid.size){
          toggleCell(r,c);
          return;
        }
      }
    }
  }

  function pointerXY(e){
    const rect=canvas.getBoundingClientRect();
    const clientX = (e.touches?e.touches[0].clientX:e.clientX);
    const clientY = (e.touches?e.touches[0].clientY:e.clientY);
    const x=clientX-rect.left;
    const y=clientY-rect.top;
    return {x,y};
  }

  canvas.addEventListener('click',(e)=>{
    const {x,y}=pointerXY(e); toggleAt(x,y);
  });
  let touchMoved=false;
  canvas.addEventListener('touchstart',()=>{touchMoved=false;}, {passive:true});
  canvas.addEventListener('touchmove',()=>{touchMoved=true;}, {passive:true});
  canvas.addEventListener('touchend',(e)=>{
    if(!touchMoved){ const {x,y}=pointerXY(e); toggleAt(x,y); }
  }, {passive:true});

  function renderErase(){
    resetBtn.setAttribute('aria-pressed', String(eraseOn));
    if(eraseOn){
      resetBtn.style.background = COLORS.ON;
      resetBtn.style.color = '#0a1320';
    }else{
      resetBtn.style.background = COLORS.OFF;
      resetBtn.style.color = COLORS.DIGIT_INK;
    }
  }

  resetBtn.addEventListener('click', ()=>{
    const wasOff = !eraseOn;
    eraseOn = !eraseOn;
    if(wasOff && eraseOn){
      // Törlés: matrix, onCount nullázása. A boards számlálót MEGTARTJUK.
      matrix=Array.from({length:grid.rows},()=>Array(grid.cols).fill(false));
      onCount=0;
      locked=false;
      syncHUD(true); // Ezzel együtt mentjük is az állapotot
      draw();
    }
    renderErase();
    saveState();
  });

  function refitAll(){ fitCanvas(); }
  window.addEventListener('resize', refitAll);
  window.addEventListener('orientationchange', refitAll);
  const ro = new ResizeObserver(()=>refitAll());
  ro.observe(hud);
  ro.observe(elBoardsHex);
  if (document.fonts && document.fonts.ready){ document.fonts.ready.then(()=>refitAll()); }

  // Boot
  initMatrix();
  refitAll();
  requestAnimationFrame(refitAll);
  setTimeout(refitAll, 0);
  setTimeout(refitAll, 50);
  setTimeout(refitAll, 150);
})();
</script>
</body>
</html>
